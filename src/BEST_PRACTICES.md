# Найкращі практики (Best Practices)

## 1. Розділення відповідальності за допомогою Custom Hooks
Я реалізував розділення логіки та представлення. Всю ігрову механіку винесено у кастомний хук `useQuiz`. Цей хук працює як контролер, який керує станом гри, таймерами та нарахуванням балів, надаючи компоненту `GamePage` лише готовий інтерфейс для відображення. Це дозволяє компонентам залишатись чистими та сфокусованими лише на рендерингу.

* **Логіка гри (Хук):**
  [useQuiz.js](src/hooks/useQuiz.js)
* **Використання в UI:**
  [GamePage.jsx](src/pages/GamePage/GamePage.jsx)

## 2. Оптимізація стану за допомогою Derived State (Похідного стану)
Я уникнув надлишкового використання `useState` для даних, які можна обчислити математично на основі існуючих пропсів або іншого стану. Замість створення зайвих змінних, які потрібно синхронізувати, я використовую обчислювані значення "на льоту". Це гарантує, що дані завжди актуальні і запобігає помилкам десинхронізації.

* **Приклад обчислення в хуку:**
  [useQuiz.js](src/hooks/useQuiz.js)

## 3. Використання React Portals для ізоляції UI
Для відображення модальних вікон я використав паттерн Portal. Це дозволяє рендерити модальне вікно поза ієрархією батьківського компонента (в окремому вузлі DOM), що вирішує типові проблеми з `z-index` та `overflow: hidden` у батьківських контейнерах.

* **Реалізація компонента Portal:**
  [Modal.jsx](src/components/UI/Modal/Modal.jsx)
* **Використання в додатку:**
  [App.jsx](src/App.jsx)

## 4. Модульний Global State Management за допомогою Zustand
Я відмовився від громіздкого Redux на користь легковагого Zustand. Я розділив стор на логічні модулі: `useSettingsStore` для конфігурації гри та `useResultsStore` для історії результатів. Також я використав middleware `persist` для автоматичного збереження даних у LocalStorage, що покращує UX при перезавантаженні сторінки.

* **Стор налаштувань:**
  [useSettingsStore.js](src/store/useSettingsStore.js)
* **Стор результатів:**
  [useResultsStore.js](src/store/useResultsStore.js)

## 5. Використання захищених маршрутів
Щоб запобігти доступу користувачів до ігрового процесу без попереднього введення імені та налаштувань, я реалізував механізм захищених маршрутів (Protected Routes). Якщо статус гри не є активним, користувача автоматично перенаправляє на головну сторінку за допомогою компонента `Navigate`.

* **Реалізація захисту в роутингу:**
  [App.jsx](src/App.jsx)
